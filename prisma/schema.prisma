datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================================================
// 1. Users
// ============================================================================
model User {
  id           Int          @id @default(autoincrement())
  username     String       @unique @db.VarChar(100)
  email        String       @unique @db.VarChar(100)
  password     String       @db.VarChar(255)
  full_name    String?      @db.VarChar(150)
  phone        String?      @db.VarChar(20)
  profile_image String?     @db.VarChar(255)
  role         Role         @default(user)
  is_active    Boolean      @default(true)
  created_at   DateTime     @default(now())
  updated_at   DateTime     @updatedAt
  deleted_at   DateTime?

  // Relations
  wishlists       Wishlist[]
  reviews         Review[]
  orders          Order[]
  contactMessages ContactMessage[]
  transactionHistory TransactionHistory[]

  @@index([email])
  @@index([role])
  @@map("users")
}

enum Role {
  user
  admin
}

// ============================================================================
// 2. Categories
// ============================================================================
model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(100)
  slug        String   @unique @db.VarChar(100)
  description String?  @db.Text
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())
  deleted_at  DateTime?

  books Book[]

  @@index([slug])
  @@map("categories")
}

// ============================================================================
// 3. Books
// ============================================================================
model Book {
  id              Int      @id @default(autoincrement())
  title           String   @db.VarChar(255)
  slug            String   @unique @db.VarChar(255)
  description     String?  @db.Text
  category_id     Int
  category        Category @relation(fields: [category_id], references: [id], onDelete: Restrict)
  author          String   @db.VarChar(255)
  publisher       String   @db.VarChar(255)
  isbn            String?  @unique @db.VarChar(20)
  price           Decimal  @db.Decimal(12, 2)
  stock           Int      @default(0)
  cover_image     String?  @db.VarChar(255)
  rating_average  Decimal  @default(0) @db.Decimal(3, 2)
  rating_count    Int      @default(0)
  is_active       Boolean  @default(true)
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt
  deleted_at      DateTime?

  // Relations
  wishlists   Wishlist[]
  reviews     Review[]
  orderItems  OrderItem[]

  @@index([title])
  @@index([category_id])
  @@index([category_id, is_active])
  @@map("books")
}

// ============================================================================
// 4. Wishlists
// ============================================================================
model Wishlist {
  id         Int      @id @default(autoincrement())
  user_id    Int
  book_id    Int
  created_at DateTime @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  book Book @relation(fields: [book_id], references: [id], onDelete: Cascade)

  @@unique([user_id, book_id])
  @@index([user_id])
  @@map("wishlists")
}

// ============================================================================
// 5. Reviews
// ============================================================================
model Review {
  id          Int      @id @default(autoincrement())
  user_id     Int
  book_id     Int
  rating      Int      // 1-5
  comment     String?  @db.Text
  is_approved Boolean  @default(true)
  created_at  DateTime @default(now())
  deleted_at  DateTime?

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  book Book @relation(fields: [book_id], references: [id], onDelete: Cascade)

  @@unique([user_id, book_id])
  @@index([book_id])
  @@index([book_id, is_approved])
  @@map("reviews")
}

// ============================================================================
// 6. Orders
// ============================================================================
model Order {
  id              Int      @id @default(autoincrement())
  order_number    String   @unique @db.VarChar(50)
  user_id         Int
  status          OrderStatus @default(pending)
  total_price     Decimal  @db.Decimal(12, 2)
  tax_amount      Decimal  @default(0) @db.Decimal(12, 2)
  shipping_cost   Decimal  @default(0) @db.Decimal(12, 2)
  final_total     Decimal  @db.Decimal(12, 2)
  shipping_address String? @db.Text
  notes           String?  @db.Text
  tracking_number String?  @db.VarChar(100)
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  user            User              @relation(fields: [user_id], references: [id], onDelete: Restrict)
  orderItems      OrderItem[]
  payment         Payment?
  transactionHistory TransactionHistory[]

  @@index([order_number])
  @@index([user_id])
  @@index([status])
  @@index([user_id, status])
  @@map("orders")
}

enum OrderStatus {
  pending
  paid
  processing
  shipped
  delivered
  cancelled
}

// ============================================================================
// 7. Order Items
// ============================================================================
model OrderItem {
  id         Int      @id @default(autoincrement())
  order_id   Int
  book_id    Int
  quantity   Int
  unit_price Decimal  @db.Decimal(12, 2)
  subtotal   Decimal  @db.Decimal(12, 2)
  created_at DateTime @default(now())

  order Order @relation(fields: [order_id], references: [id], onDelete: Cascade)
  book  Book  @relation(fields: [book_id], references: [id], onDelete: Restrict)

  @@index([order_id])
  @@map("order_items")
}

// ============================================================================
// 8. Payments
// ============================================================================
model Payment {
  id              Int      @id @default(autoincrement())
  order_id        Int      @unique
  payment_method  PaymentMethod @default(bank_transfer)
  amount          Decimal  @db.Decimal(12, 2)
  status          PaymentStatus @default(pending)
  transaction_id  String?  @db.VarChar(100)
  paid_at         DateTime?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  order Order @relation(fields: [order_id], references: [id], onDelete: Restrict)

  @@index([order_id])
  @@index([status])
  @@map("payments")
}

enum PaymentMethod {
  bank_transfer
  credit_card
  ewallet
}

enum PaymentStatus {
  pending
  paid
  failed
}

// ============================================================================
// 9. Contact Messages
// ============================================================================
model ContactMessage {
  id          Int      @id @default(autoincrement())
  user_id     Int
  subject     String   @db.VarChar(255)
  message     String   @db.Text
  status      ContactStatus @default(unread)
  admin_reply String?  @db.Text
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([status])
  @@map("contact_messages")
}

enum ContactStatus {
  unread
  read
  replied
}

// ============================================================================
// 10. Transaction History
// ============================================================================
model TransactionHistory {
  id              Int      @id @default(autoincrement())
  order_id        Int?
  user_id         Int
  description     String?  @db.VarChar(255)
  amount          Decimal? @db.Decimal(12, 2)
  transaction_type TransactionType @default(purchase)
  created_at      DateTime @default(now())

  order Order? @relation(fields: [order_id], references: [id], onDelete: SetNull)
  user  User   @relation(fields: [user_id], references: [id], onDelete: Restrict)

  @@index([user_id])
  @@index([created_at])
  @@map("transaction_history")
}

enum TransactionType {
  purchase
  refund
}
